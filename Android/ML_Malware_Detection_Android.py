import os
import apk
import copy
#import permission_classifier
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import timeit
#import seaborn
# Import ML algorithms
from sklearn.model_selection import train_test_split  # import thing that will split the array into train/test subsets
from sklearn.metrics import confusion_matrix  # Allows us to measure performance: gives true/false positives/negatives
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import StandardScaler  # Scale the features to be b/w 0 and 1 to standardize them
from sklearn.neural_network import MLPClassifier  # A multi-layer perceptron neural network
from sklearn.ensemble import RandomForestClassifier  # Random forests, best classical ML approach to take

# Make a class called apkFile, to store apk files

startTime = timeit.default_timer();

class apkFile:
    # Constructor for apk class
    def __init__(self, filename):
        self.apkfile = apk.APK(filename)  # make an object, called apkfile, of the APK class from the apk library
        #self.filesize = self.apkfile.file_size
        #self.cert = self.apkfile.get_certificate(filename)  # google certification
        #self.cert_as_bool = cert_converter(self, self.cert)
        self.permissions = self.apkfile.get_permissions() # file permissions as a string
        temp_list = permission_classifier(self.permissions)
        self.Perm_READ_CALENDAR = temp_list[0]
        self.Perm_WRITE_CALENDAR = temp_list[1]
        self.Perm_CAMERA = temp_list[2]
        self.Perm_READ_CONTACTS = temp_list[3]
        self.Perm_WRITE_CONTACTS = temp_list[4]
        self.Perm_GET_ACCOUNTS = temp_list[5]
        self.Perm_ACCESS_FINE_LOCATION = temp_list[6]
        self.Perm_ACCESS_COARSE_LOCATION = temp_list[7]
        self.Perm_RECORD_AUDIO = temp_list[8]
        self.Perm_READ_PHONE_STATE = temp_list[9]
        self.Perm_CALL_PHONE = temp_list[10]
        self.Perm_READ_CALL_LOG = temp_list[11]
        self.Perm_WRITE_CALL_LOG = temp_list[12]
        self.Perm_ADD_VOICEMAIL = temp_list[13]
        self.Perm_USE_SIP = temp_list[14]
        self.Perm_PROCESS_OUTGOING_CALLS = temp_list[15]
        self.Perm_BODY_SENSORS = temp_list[16]
        self.Perm_SEND_SMS = temp_list[17]
        self.Perm_RECEIVE_SMS = temp_list[18]
        self.Perm_READ_SMS = temp_list[19]
        self.Perm_RECEIVE_WAP_PUSH = temp_list[20]
        self.Perm_RECEIVE_MMS = temp_list[21]
        self.Perm_READ_EXTERNAL_STORAGE = temp_list[21]
        self.Perm_WRITE_EXTERNAL_STORAGE = temp_list[22]
        #self.providers = self.apkfile.get_providers()
        #self.activities = self.apkfile.get_activities()
        #self.services = self.apkfile.get_services()
        #self.receivers = self.apkfile.get_receivers()

    # function that constructs a dictionary entry for an object (individual apk file)

   # def getPermissions(self):
       # return self.permissions

    def construct(self):
        sample = {}
        for attr, k in self.__dict__.iteritems():  # GO OVER THIS CODE W CLINTON
            if (attr != "apkfile" and attr != "permissions"):
                sample[attr] = k
        return sample

# This function's purpose is to take in the files of an android app, and then classify them as 1 or 0.
def permission_classifier(list):
# dangerous android permission counters
    READ_CALENDAR = 0
    WRITE_CALENDAR = 0
    CAMERA = 0
    READ_CONTACTS = 0
    WRITE_CONTACTS = 0
    GET_ACCOUNTS = 0
    ACCESS_FINE_LOCATION = 0
    ACCESS_COARSE_LOCATION = 0
    RECORD_AUDIO = 0
    READ_PHONE_STATE = 0
    CALL_PHONE = 0
    READ_CALL_LOG = 0
    WRITE_CALL_LOG = 0
    ADD_VOICEMAIL = 0
    USE_SIP = 0
    PROCESS_OUTGOING_CALLS = 0
    BODY_SENSORS = 0
    SEND_SMS = 0
    RECEIVE_SMS = 0
    READ_SMS = 0
    RECEIVE_WAP_PUSH = 0
    RECEIVE_MMS = 0
    READ_EXTERNAL_STORAGE = 0
    WRITE_EXTERNAL_STORAGE = 0

    dangerous = [
    'android.permission.READ_CALENDAR',
    'android.permission.WRITE_CALENDAR',
    'android.permission.CAMERA',
    'android.permission.READ_CONTACTS',
    'android.permission.WRITE_CONTACTS',
    'android.permission.GET_ACCOUNTS',
    'android.permission.ACCESS_FINE_LOCATION',
    'android.permission.ACCESS_COARSE_LOCATION',
    'android.permission.RECORD_AUDIO',
    'android.permission.READ_PHONE_STATE',
    'android.permission.CALL_PHONE',
    'android.permission.READ_CALL_LOG',
    'android.permission.WRITE_CALL_LOG',
    'android.permission.ADD_VOICEMAIL',
    'android.permission.USE_SIP',
    'android.permission.PROCESS_OUTGOING_CALLS',
    'android.permission.BODY_SENSORS',
    'android.permission.SEND_SMS',
    'android.permission.RECEIVE_SMS',
    'android.permission.READ_SMS',
    'android.permission.RECEIVE_WAP_PUSH',
    'android.permission.RECEIVE_MMS',
    'android.permission.READ_EXTERNAL_STORAGE',
    'android.permission.WRITE_EXTERNAL_STORAGE' ]

    dangerouscount = [READ_CALENDAR,
    WRITE_CALENDAR,
    CAMERA,
    READ_CONTACTS,
    WRITE_CONTACTS,
    GET_ACCOUNTS,
    ACCESS_FINE_LOCATION,
    ACCESS_COARSE_LOCATION,
    RECORD_AUDIO,
    READ_PHONE_STATE,
    CALL_PHONE,
    READ_CALL_LOG,
    WRITE_CALL_LOG,
    ADD_VOICEMAIL,
    USE_SIP,
    PROCESS_OUTGOING_CALLS,
    BODY_SENSORS,
    SEND_SMS,
    RECEIVE_SMS,
    READ_SMS,
    RECEIVE_WAP_PUSH,
    RECEIVE_MMS,
    READ_EXTERNAL_STORAGE,
    WRITE_EXTERNAL_STORAGE ]

    for i in range(0, len(list)) :
        for j in range(0,len(dangerous)) :
            if list[i] == dangerous[j] :
                dangerouscount[j] += 1

    return dangerouscount;

#returns a list of the permission names
def get_permission_names() :
    return [
    'android.permission.READ_CALENDAR',
    'android.permission.WRITE_CALENDAR',
    'android.permission.CAMERA',
    'android.permission.READ_CONTACTS',
    'android.permission.WRITE_CONTACTS',
    'android.permission.GET_ACCOUNTS',
    'android.permission.ACCESS_FINE_LOCATION',
    'android.permission.ACCESS_COARSE_LOCATION',
    'android.permission.RECORD_AUDIO',
    'android.permission.READ_PHONE_STATE',
    'android.permission.CALL_PHONE',
    'android.permission.READ_CALL_LOG',
    'android.permission.WRITE_CALL_LOG',
    'android.permission.ADD_VOICEMAIL',
    'android.permission.USE_SIP',
    'android.permission.PROCESS_OUTGOING_CALLS',
    'android.permission.BODY_SENSORS',
    'android.permission.SEND_SMS',
    'android.permission.RECEIVE_SMS',
    'android.permission.READ_SMS',
    'android.permission.RECEIVE_WAP_PUSH',
    'android.permission.RECEIVE_MMS',
    'android.permission.READ_EXTERNAL_STORAGE',
    'android.permission.WRITE_EXTERNAL_STORAGE' ]

def apk2vec(directory):
    dataset = {}
    permissionsTEMP=[]

    for subdir, dirs, files in os.walk(directory):
        for f in files:
            file_path = os.path.join(subdir, f)
            try:
                apk = apkFile(file_path)
                dataset[str(f)] = apk.construct()
                '''
                temp = []
                for i in range(len(apk.permissions)):
                    temp.append(0)
                for i in range(len(apk.permissions)):
                    temp[i] = ___
                for i in range(len(apk.permissions)):
                    permissionsTEMP[i]+=temp[i]
                '''
            except Exception as e:
                print(e)
    return dataset


    
def vec2csv(dataset, filename):
    df = pd.DataFrame(dataset)
    df = df.transpose()  # transpose to have the features as columns and samples as rows
    df.to_csv(filename, sep=',', encoding='utf-8')  # ASK CLINTON

# The code that calls the functions and makes the two files
directoryPath_Malicious = 'C:\\Users\\cyberdefenders\\Desktop\\MaliciousAPKFiles' # the directory to index, with mal files
directoryPath_Clean = 'C:\\Users\\cyberdefenders\\Desktop\\CleanAPKFiles'  # the clean directory to index

dataset_Malicious = apk2vec(directoryPath_Malicious)
dataset_Clean = apk2vec(directoryPath_Clean)

vec2csv(dataset_Malicious, 'dataset_Malicious.csv')
vec2csv(dataset_Clean, 'dataset_Clean.csv')

malicious = pd.read_csv("dataset_Malicious.csv")
clean = pd.read_csv("dataset_Clean.csv")

malicious['clean'] = 0
clean['clean'] = 1

# Visualize data using matplotlib - TO BE ADDED

def dataSet2performance(dataSet):
    newDictionary = copy.deepcopy((dataSet[next(iter(dataSet))]))
    for keyT in newDictionary:
        newDictionary[keyT] = 0
    for key0 in dataSet:
        for key1 in newDictionary:
            for key2 in dataSet[key0]:
                if key1 == key2:
                    newDictionary[key1] += dataSet[key0][key2]

    objects = []
    for i in (range(len(newDictionary))):
        objects.append(str(i))
    y_pos = np.arange(len(objects))
    performance = []
    permisisonNames = []
    for key in newDictionary:
        performance.append(newDictionary[key])
        permisisonNames.append(key)
    print(len(dataSet))
    for i in (range(len(performance))):
        performance[i] = (float(performance[i]) / len(dataSet)) * 100
    return performance, permisisonNames

n = len(dataset_Malicious[next(iter(dataset_Malicious))])
X = np.arange(n)
Y1, Y1permisisonNames = dataSet2performance(dataset_Clean)
Y2, Y2permisisonNames = dataSet2performance(dataset_Malicious)
fig1=plt.bar(X, Y1, facecolor='#9999ff', edgecolor='white')
Y2 = [x * -1 for x in Y2]
fig2=plt.bar(X, Y2, facecolor='#ff9999', edgecolor='white')

plt.xlabel("Permissions")
plt.ylabel("Percentage of files")
plt.grid()
plt.legend([fig1,fig2],['Non-Malicious','Malicious'])
plt.title("PERCENTAGE of files vs PERMISSIONS that affect them")
plt.show()

# Merge dataset
dataset_Merged = [malicious, clean]
dataset = pd.concat(dataset_Merged)
#a = type(dataset_Merged);b = type(dataset);
vec2csv(dataset.transpose(), 'dataset_Merged.csv')

# Dataset prep, algorithm implementation
state = np.random.randint(100)
y = dataset['clean']
X = dataset.drop('clean', axis=1)
X = np.asarray(X)
y = np.asarray(y)

#Assigned dataset for training and testing
X = X[:, 1:]  # get rid of the zeroth column of X (the filename)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=0)

# Random Forests
classifier1 = RandomForestClassifier()
classifier1.fit(X_train, y_train)
y_pred = classifier1.predict(X_test)

tn, fp, fn, tp = confusion_matrix(y_test, y_pred).ravel()
acc= accuracy_score(y_test, y_pred)

print("TN = ", tn)
print("TP = ", tp)
print("FP = ", fp)
print("FN = ", fn)
print("Accuracy = ", acc)

# MLP
scaler = StandardScaler()
scaler.fit(X_train)
X_train = scaler.transform(X_train)
X_test = scaler.transform(X_test)

mlp = MLPClassifier(hidden_layer_sizes=(12, 12, 12, 12, 12, 12))
mlp.fit(X_train, y_train)
predictions = mlp.predict(X_test)

tn, fp, fn, tp = confusion_matrix(y_test, predictions).ravel()
acc= accuracy_score(y_test, predictions )

print("TN = ", tn)
print("TP = ", tp)
print("FP = ", fp)
print("FN = ", fn)
print("Accuracy = ", acc)
endTime = timeit.default_timer();

for i in Y2permisisonNames:
    print(i)

print("Run time: ", endTime - startTime, " seconds")