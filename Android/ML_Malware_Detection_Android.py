import os
import apk
#import permission_classifier
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn
# Import ML algorithms
from sklearn.model_selection import train_test_split  # import thing that will split the array into train/test subsets
from sklearn.metrics import confusion_matrix  # Allows us to measure performance: gives true/false positives/negatives
from sklearn.preprocessing import StandardScaler  # Scale the features to be b/w 0 and 1 to standardize them
from sklearn.neural_network import MLPClassifier  # A multi-layer perceptron neural network
from sklearn.ensemble import RandomForestClassifier  # Random forests, best classical ML approach to take

# Make a class called apkFile, to store apk files

class apkFile:
    # Constructor for apk class
    def __init__(self, filename):
        self.apkfile = apk.APK(filename)  # make an object, called apkfile, of the APK class from the apk library
        self.filesize = self.apkfile.file_size
        self.cert = self.apkfile.get_certificate(filename)  # google certification
        self.cert_as_bool = cert_converter(self, self.cert)
        self.permissions = self.apkfile.get_permissions() # file permissions as a string
        temp_list = permission_classifier(self.permissions)
        self.Perm_READ_CALENDAR = temp_list[0]
        self.Perm_WRITE_CALENDAR = temp_list[1]
        self.Perm_CAMERA = temp_list[2]
        self.Perm_READ_CONTACTS = temp_list[3]
        self.Perm_WRITE_CONTACTS = temp_list[4]
        self.Perm_GET_ACCOUNTS = temp_list[5]
        self.Perm_ACCESS_FINE_LOCATION = temp_list[6]
        self.Perm_ACCESS_COARSE_LOCATION = temp_list[7]
        self.Perm_RECORD_AUDIO = temp_list[8]
        self.Perm_READ_PHONE_STATE = temp_list[9]
        self.Perm_CALL_PHONE = temp_list[10]
        self.Perm_READ_CALL_LOG = temp_list[11]
        self.Perm_WRITE_CALL_LOG = temp_list[12]
        self.Perm_ADD_VOICEMAIL = temp_list[13]
        self.Perm_USE_SIP = temp_list[14]
        self.Perm_PROCESS_OUTGOING_CALLS = temp_list[15]
        self.Perm_BODY_SENSORS = temp_list[16]
        self.Perm_SEND_SMS = temp_list[17]
        self.Perm_RECEIVE_SMS = temp_list[18]
        self.Perm_READ_SMS = temp_list[19]
        self.Perm_RECEIVE_WAP_PUSH = temp_list[20]
        self.Perm_RECEIVE_MMS = temp_list[21]
        self.Perm_READ_EXTERNAL_STORAGE = temp_list[21]
        self.Perm_WRITE_EXTERNAL_STORAGE = temp_list[22]
        #self.providers = self.apkfile.get_providers()
        #self.activities = self.apkfile.get_activities()
        #self.services = self.apkfile.get_services()
        #self.receivers = self.apkfile.get_receivers()

    # function that constructs a dictionary entry for an object (individual apk file)

   # def getPermissions(self):
       # return self.permissions

    def construct(self):
        sample = {}
        for attr, k in self.__dict__.iteritems():  # GO OVER THIS CODE W CLINTON
            if (attr != "apkfile" and attr !="cert" and attr != "permissions"):
                sample[attr] = k
        return sample

def cert_converter(self, cert) :
    cert2 = cert[0]
    if cert2 == True:
        flag = 1
    else:
        flag = 0
    return flag

# This function's purpose is to take in the files of an android app, and then classify them as 1 or 0.
def permission_classifier(list):
# dangerous android permission counters
    READ_CALENDAR = 0
    WRITE_CALENDAR = 0
    CAMERA = 0
    READ_CONTACTS = 0
    WRITE_CONTACTS = 0
    GET_ACCOUNTS = 0
    ACCESS_FINE_LOCATION = 0
    ACCESS_COARSE_LOCATION = 0
    RECORD_AUDIO = 0
    READ_PHONE_STATE = 0
    CALL_PHONE = 0
    READ_CALL_LOG = 0
    WRITE_CALL_LOG = 0
    ADD_VOICEMAIL = 0
    USE_SIP = 0
    PROCESS_OUTGOING_CALLS = 0
    BODY_SENSORS = 0
    SEND_SMS = 0
    RECEIVE_SMS = 0
    READ_SMS = 0
    RECEIVE_WAP_PUSH = 0
    RECEIVE_MMS = 0
    READ_EXTERNAL_STORAGE = 0
    WRITE_EXTERNAL_STORAGE = 0

    dangerous = [
    'android.permission.READ_CALENDAR',
    'android.permission.WRITE_CALENDAR',
    'android.permission.CAMERA',
    'android.permission.READ_CONTACTS',
    'android.permission.WRITE_CONTACTS',
    'android.permission.GET_ACCOUNTS',
    'android.permission.ACCESS_FINE_LOCATION',
    'android.permission.ACCESS_COARSE_LOCATION',
    'android.permission.RECORD_AUDIO',
    'android.permission.READ_PHONE_STATE',
    'android.permission.CALL_PHONE',
    'android.permission.READ_CALL_LOG',
    'android.permission.WRITE_CALL_LOG',
    'android.permission.ADD_VOICEMAIL',
    'android.permission.USE_SIP',
    'android.permission.PROCESS_OUTGOING_CALLS',
    'android.permission.BODY_SENSORS',
    'android.permission.SEND_SMS',
    'android.permission.RECEIVE_SMS',
    'android.permission.READ_SMS',
    'android.permission.RECEIVE_WAP_PUSH',
    'android.permission.RECEIVE_MMS',
    'android.permission.READ_EXTERNAL_STORAGE',
    'android.permission.WRITE_EXTERNAL_STORAGE' ]

    dangerouscount = [READ_CALENDAR,
    WRITE_CALENDAR,
    CAMERA,
    READ_CONTACTS,
    WRITE_CONTACTS,
    GET_ACCOUNTS,
    ACCESS_FINE_LOCATION,
    ACCESS_COARSE_LOCATION,
    RECORD_AUDIO,
    READ_PHONE_STATE,
    CALL_PHONE,
    READ_CALL_LOG,
    WRITE_CALL_LOG,
    ADD_VOICEMAIL,
    USE_SIP,
    PROCESS_OUTGOING_CALLS,
    BODY_SENSORS,
    SEND_SMS,
    RECEIVE_SMS,
    READ_SMS,
    RECEIVE_WAP_PUSH,
    RECEIVE_MMS,
    READ_EXTERNAL_STORAGE,
    WRITE_EXTERNAL_STORAGE ]

    for i in range(0, len(list)) :
        for j in range(0,len(dangerous)) :
            if list[i] == dangerous[j] :
                dangerouscount[j] += 1

    return dangerouscount;

#returns a list of the permission names
def get_permission_names() :
    return [
    'android.permission.READ_CALENDAR',
    'android.permission.WRITE_CALENDAR',
    'android.permission.CAMERA',
    'android.permission.READ_CONTACTS',
    'android.permission.WRITE_CONTACTS',
    'android.permission.GET_ACCOUNTS',
    'android.permission.ACCESS_FINE_LOCATION',
    'android.permission.ACCESS_COARSE_LOCATION',
    'android.permission.RECORD_AUDIO',
    'android.permission.READ_PHONE_STATE',
    'android.permission.CALL_PHONE',
    'android.permission.READ_CALL_LOG',
    'android.permission.WRITE_CALL_LOG',
    'android.permission.ADD_VOICEMAIL',
    'android.permission.USE_SIP',
    'android.permission.PROCESS_OUTGOING_CALLS',
    'android.permission.BODY_SENSORS',
    'android.permission.SEND_SMS',
    'android.permission.RECEIVE_SMS',
    'android.permission.READ_SMS',
    'android.permission.RECEIVE_WAP_PUSH',
    'android.permission.RECEIVE_MMS',
    'android.permission.READ_EXTERNAL_STORAGE',
    'android.permission.WRITE_EXTERNAL_STORAGE' ]

def apk2vec(directory):
    dataset = {}
    for subdir, dirs, files in os.walk(directory):
        for f in files:
            file_path = os.path.join(subdir, f)
            try:
                apk = apkFile(file_path)
                dataset[str(f)] = apk.construct()
            except Exception as e:
                print(e)
    return dataset

def apk2vec(directory):
    dataset = {}
    for subdir, dirs, files in os.walk(directory):
        for f in files:
            file_path = os.path.join(subdir, f)
            try:
                apk = apkFile(file_path)
                dataset[str(f)] = apk.construct()
                
            except Exception as e:
                print(e)
    return dataset
    
def vec2csv(dataset, filename):
    df = pd.DataFrame(dataset)
    df = df.transpose()  # transpose to have the features as columns and samples as rows
    df.to_csv(filename, sep=',', encoding='utf-8')  # ASK CLINTON

# The code that calls the functions and makes the two files
directoryPath_Malicious = 'C:\\Polina\\apkCLEAN'  # the directory to index, with mal files
directoryPath_Clean = 'C:\\Polina\\apkCLEAN'  # the clean directory to index

dataset_Malicious = apk2vec(directoryPath_Malicious)
dataset_Clean = apk2vec(directoryPath_Clean)

vec2csv(dataset_Malicious, 'dataset_Malicious.csv')
vec2csv(dataset_Clean, 'dataset_Clean.csv')

malicious = pd.read_csv("dataset_Malicious.csv")
clean = pd.read_csv("dataset_Clean.csv")

malicious['clean'] = 0
clean['clean'] = 1

# Visualize data using stats - TO BE ADDED
print("Clean Files Statistics")
clean.describe()
print("Malicious Files Statistics")
malicious.describe()
"""
# Visualize data using matplotlib - TO BE ADDED

fig,ax = plt.subplots()
x = malicious['cert']
y = malicious['clean']
ax.scatter(x,y,color='r',label='Malicious')
x1 = clean['IATRVA']
y1 = clean['clean']
ax.scatter(x1,y1,color='b',label='Cleanfiles')
ax.legend(loc="right")

fig,ax = plt.subplots()
x = malicious['DebugRVA']
y = malicious['clean']
ax.scatter(x,y,color='r',label='Malicious')
x1 = clean['DebugRVA']
y1 = clean['clean']
ax.scatter(x1,y1,color='b',label='Cleanfiles')
ax.legend(loc="right")

fig,ax = plt.subplots()
x = malicious['ExportSize']
y = malicious['clean']
ax.scatter(x,y,color='r',label='Malicious')
x1 = clean['ExportSize']
y1 = clean['clean']
ax.scatter(x1,y1,color='b',label='Cleanfiles')
ax.legend(loc="right")
"""
# Merge dataset
dataset_Merged = [malicious, clean]
dataset = pd.concat(dataset_Merged)
#a = type(dataset_Merged);b = type(dataset);
vec2csv(dataset.transpose(), 'dataset_Merged.csv')

# Dataset prep, algorithm implementation

state = np.random.randint(100)
y = dataset['clean']
X = dataset.drop('clean', axis=1)
X = np.asarray(X)
y = np.asarray(y)

X = X[:, 1:]  # get rid of the zeroth column of X (the filename), and the last column (the file path) -P
#print(X[1, 11])
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=0)

# Random Forests
classifier1 = RandomForestClassifier()
classifier1.fit(X_train, y_train)
y_pred = classifier1.predict(X_test)

tn, fp, fn, tp = confusion_matrix(y_test, y_pred).ravel()
print("TN = ", tn)
print("TP = ", tp)
print("FP = ", fp)
print("FN = ", fn)

# MLP
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)
scaler = StandardScaler()
scaler.fit(X_train)
X_train = scaler.transform(X_train)
X_test = scaler.transform(X_test)

mlp = MLPClassifier(hidden_layer_sizes=(12, 12, 12, 12, 12, 12))
mlp.fit(X_train, y_train)
predictions = mlp.predict(X_test)

tn, fp, fn, tp = confusion_matrix(y_test, predictions).ravel()
print("TN = ", tn)
print("TP = ", tp)
print("FP = ", fp)
print("FN = ", fn)